{"ast":null,"code":"import { getPossibleBishopMoves, getPossibleKingMoves, getPossibleKnightMoves, getPossiblePawnMoves, getPossibleQueenMoves, getPossibleRookMoves, getCastlingMoves } from \"../Referee/rules\";\nimport { PieceType, TeamType } from \"../Types\";\nimport { Position } from \"./Position\";\nexport class Board {\n  constructor(pieces, totalTurns) {\n    this.pieces = void 0;\n    this.totalTurns = void 0;\n    this.winningTeam = void 0;\n    this.pieces = pieces;\n    this.totalTurns = totalTurns;\n  }\n  get currentTeam() {\n    return this.totalTurns % 2 === 0 ? TeamType.OPPONENT : TeamType.OUR;\n  }\n  calculateAllMoves() {\n    // Calculate the moves of all the pieces\n    for (const piece of this.pieces) {\n      piece.possibleMoves = this.getValidMoves(piece, this.pieces);\n    }\n\n    // Calculate castling moves\n    for (const king of this.pieces.filter(p => p.isKing)) {\n      if (king.possibleMoves === undefined) continue;\n      king.possibleMoves = [...king.possibleMoves, ...getCastlingMoves(king, this.pieces)];\n    }\n\n    // Check if the current team moves are valid\n    this.checkCurrentTeamMoves();\n\n    // Remove the posibble moves for the team that is not playing\n    for (const piece of this.pieces.filter(p => p.team !== this.currentTeam)) {\n      piece.possibleMoves = [];\n    }\n\n    // Check if the playing team still has moves left\n    // Otherwise, checkmate!\n    if (this.pieces.filter(p => p.team === this.currentTeam).some(p => p.possibleMoves !== undefined && p.possibleMoves.length > 0)) return;\n    this.winningTeam = this.currentTeam === TeamType.OUR ? TeamType.OPPONENT : TeamType.OUR;\n  }\n  checkCurrentTeamMoves() {\n    // Loop through all the current team's pieces\n    for (const piece of this.pieces.filter(p => p.team === this.currentTeam)) {\n      if (piece.possibleMoves === undefined) continue;\n\n      // Simulate all the piece moves\n      for (const move of piece.possibleMoves) {\n        const simulatedBoard = this.clone();\n\n        // Remove the piece at the destination position\n        simulatedBoard.pieces = simulatedBoard.pieces.filter(p => !p.samePosition(move));\n\n        // Get the piece of the cloned board\n        const clonedPiece = simulatedBoard.pieces.find(p => p.samePiecePosition(piece));\n        // console.log(clonedPiece,piece);\n        if (clonedPiece) clonedPiece.position = move.clone();\n\n        // Get the king of the cloned board\n        const clonedKing = simulatedBoard.pieces.find(p => p.isKing && p.team === simulatedBoard.currentTeam);\n\n        // Loop through all enemy pieces, update their possible moves\n        // And check if the current team's king will be in danger\n        for (const enemy of simulatedBoard.pieces.filter(p => p.team !== simulatedBoard.currentTeam)) {\n          enemy.possibleMoves = simulatedBoard.getValidMoves(enemy, simulatedBoard.pieces);\n          if (enemy.isPawn) {\n            if (enemy.possibleMoves.some(m => m.x !== enemy.position.x && m.samePosition(clonedKing.position))) {\n              var _piece$possibleMoves;\n              piece.possibleMoves = (_piece$possibleMoves = piece.possibleMoves) === null || _piece$possibleMoves === void 0 ? void 0 : _piece$possibleMoves.filter(m => !m.samePosition(move));\n            }\n          } else {\n            if (enemy.possibleMoves.some(m => m.samePosition(clonedKing.position))) {\n              var _piece$possibleMoves2;\n              piece.possibleMoves = (_piece$possibleMoves2 = piece.possibleMoves) === null || _piece$possibleMoves2 === void 0 ? void 0 : _piece$possibleMoves2.filter(m => !m.samePosition(move));\n            }\n          }\n        }\n      }\n    }\n  }\n  getValidMoves(piece, boardState) {\n    switch (piece.type) {\n      case PieceType.PAWN:\n        return getPossiblePawnMoves(piece, boardState);\n      case PieceType.KNIGHT:\n        return getPossibleKnightMoves(piece, boardState);\n      case PieceType.BISHOP:\n        return getPossibleBishopMoves(piece, boardState);\n      case PieceType.ROOK:\n        return getPossibleRookMoves(piece, boardState);\n      case PieceType.QUEEN:\n        return getPossibleQueenMoves(piece, boardState);\n      case PieceType.KING:\n        return getPossibleKingMoves(piece, boardState);\n      default:\n        return [];\n    }\n  }\n  playMove(enPassantMove, validMove, playedPiece, destination) {\n    const pawnDirection = playedPiece.team === TeamType.OUR ? 1 : -1;\n    const destinationPiece = this.pieces.find(p => p.samePosition(destination));\n\n    // If the move is a castling move do this\n    if (playedPiece.isKing && destinationPiece !== null && destinationPiece !== void 0 && destinationPiece.isRook && destinationPiece.team === playedPiece.team) {\n      const direction = destinationPiece.position.x - playedPiece.position.x > 0 ? 1 : -1;\n      const newKingXPosition = playedPiece.position.x + direction * 2;\n      this.pieces = this.pieces.map(p => {\n        if (p.samePiecePosition(playedPiece)) {\n          p.position.x = newKingXPosition;\n        } else if (p.samePiecePosition(destinationPiece)) {\n          p.position.x = newKingXPosition - direction;\n        }\n        return p;\n      });\n      this.calculateAllMoves();\n      return true;\n    }\n    if (enPassantMove) {\n      this.pieces = this.pieces.reduce((results, piece) => {\n        if (piece.samePiecePosition(playedPiece)) {\n          if (piece.isPawn) piece.enPassant = false;\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true;\n          results.push(piece);\n        } else if (!piece.samePosition(new Position(destination.x, destination.y - pawnDirection))) {\n          if (piece.isPawn) {\n            piece.enPassant = false;\n          }\n          results.push(piece);\n        }\n        return results;\n      }, []);\n      this.calculateAllMoves();\n    } else if (validMove) {\n      //UPDATES THE PIECE POSITION\n      //AND IF A PIECE IS ATTACKED, REMOVES IT\n      this.pieces = this.pieces.reduce((results, piece) => {\n        // Piece that we are currently moving\n        if (piece.samePiecePosition(playedPiece)) {\n          //SPECIAL MOVE\n          if (piece.isPawn) piece.enPassant = Math.abs(playedPiece.position.y - destination.y) === 2 && piece.type === PieceType.PAWN;\n          piece.position.x = destination.x;\n          piece.position.y = destination.y;\n          piece.hasMoved = true;\n          results.push(piece);\n        } else if (!piece.samePosition(destination)) {\n          if (piece.isPawn) {\n            piece.enPassant = false;\n          }\n          results.push(piece);\n        }\n\n        // The piece at the destination location\n        // Won't be pushed in the results\n        return results;\n      }, []);\n      this.calculateAllMoves();\n    } else {\n      return false;\n    }\n    return true;\n  }\n  updateTurns(x) {\n    this.totalTurns = x;\n  }\n  clone() {\n    return new Board(this.pieces.map(p => p.clone()), this.totalTurns);\n  }\n}","map":{"version":3,"names":["getPossibleBishopMoves","getPossibleKingMoves","getPossibleKnightMoves","getPossiblePawnMoves","getPossibleQueenMoves","getPossibleRookMoves","getCastlingMoves","PieceType","TeamType","Position","Board","constructor","pieces","totalTurns","winningTeam","currentTeam","OPPONENT","OUR","calculateAllMoves","piece","possibleMoves","getValidMoves","king","filter","p","isKing","undefined","checkCurrentTeamMoves","team","some","length","move","simulatedBoard","clone","samePosition","clonedPiece","find","samePiecePosition","position","clonedKing","enemy","isPawn","m","x","_piece$possibleMoves","_piece$possibleMoves2","boardState","type","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","playMove","enPassantMove","validMove","playedPiece","destination","pawnDirection","destinationPiece","isRook","direction","newKingXPosition","map","reduce","results","enPassant","y","hasMoved","push","Math","abs","updateTurns"],"sources":["/home/animesh/Desktop/SummerDev/Chess-40/src/models/Board.ts"],"sourcesContent":["import { getPossibleBishopMoves, getPossibleKingMoves, getPossibleKnightMoves, getPossiblePawnMoves, getPossibleQueenMoves, getPossibleRookMoves, getCastlingMoves } from \"../Referee/rules\";\nimport { PieceType, TeamType } from \"../Types\";\nimport { Pawn } from \"./Pawn\";\nimport { Piece } from \"./Piece\";\nimport { Position } from \"./Position\";\n\nexport class Board {\n    pieces: Piece[];\n    totalTurns: number;\n    winningTeam?: TeamType;\n\n    constructor(pieces: Piece[], totalTurns: number) {\n        this.pieces = pieces;\n        this.totalTurns = totalTurns;\n    }\n\n    get currentTeam(): TeamType {\n        return this.totalTurns % 2 === 0 ? TeamType.OPPONENT : TeamType.OUR;\n    }\n\n    calculateAllMoves() {\n        // Calculate the moves of all the pieces\n        for (const piece of this.pieces) {\n            piece.possibleMoves = this.getValidMoves(piece, this.pieces)\n        }\n\n        // Calculate castling moves\n        for (const king of this.pieces.filter(p => p.isKing)) {\n            if (king.possibleMoves === undefined) continue;\n\n            king.possibleMoves = [...king.possibleMoves, ...getCastlingMoves(king, this.pieces)];\n        }\n\n        // Check if the current team moves are valid\n        this.checkCurrentTeamMoves();\n\n        // Remove the posibble moves for the team that is not playing\n        for (const piece of\n            this.pieces.filter(p => p.team !== this.currentTeam)) {\n            piece.possibleMoves = [];\n        }\n\n        // Check if the playing team still has moves left\n        // Otherwise, checkmate!\n        if (this.pieces.filter(p => p.team === this.currentTeam)\n            .some(p => p.possibleMoves !== undefined && p.possibleMoves.length > 0)) return;\n\n        this.winningTeam = (this.currentTeam === TeamType.OUR) ? TeamType.OPPONENT : TeamType.OUR;\n    }\n\n    checkCurrentTeamMoves() {\n        // Loop through all the current team's pieces\n        for (const piece of this.pieces.filter(p => p.team === this.currentTeam)) {\n            if (piece.possibleMoves === undefined) continue;\n\n            // Simulate all the piece moves\n            for (const move of piece.possibleMoves) {\n                const simulatedBoard = this.clone();\n\n                // Remove the piece at the destination position\n                simulatedBoard.pieces = simulatedBoard.pieces.filter(p => !p.samePosition(move));\n\n                // Get the piece of the cloned board\n                const clonedPiece = simulatedBoard.pieces.find(p => p.samePiecePosition(piece))!;\n                // console.log(clonedPiece,piece);\n                if(clonedPiece) clonedPiece.position = move.clone();\n\n                // Get the king of the cloned board\n                const clonedKing = simulatedBoard.pieces.find(p => p.isKing && p.team === simulatedBoard.currentTeam)!;\n\n                // Loop through all enemy pieces, update their possible moves\n                // And check if the current team's king will be in danger\n                for (const enemy of simulatedBoard.pieces.filter(p => p.team !== simulatedBoard.currentTeam)) {\n                    enemy.possibleMoves = simulatedBoard.getValidMoves(enemy, simulatedBoard.pieces);\n\n                    if (enemy.isPawn) {\n                        if (enemy.possibleMoves.some(m => m.x !== enemy.position.x\n                            && m.samePosition(clonedKing.position))) {\n                            piece.possibleMoves = piece.possibleMoves?.filter(m => !m.samePosition(move));\n                        }\n                    } else {\n                        if (enemy.possibleMoves.some(m => m.samePosition(clonedKing.position))) {\n                            piece.possibleMoves = piece.possibleMoves?.filter(m => !m.samePosition(move));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    getValidMoves(piece: Piece, boardState: Piece[]): Position[] {\n        switch (piece.type) {\n            case PieceType.PAWN:\n                return getPossiblePawnMoves(piece, boardState);\n            case PieceType.KNIGHT:\n                return getPossibleKnightMoves(piece, boardState);\n            case PieceType.BISHOP:\n                return getPossibleBishopMoves(piece, boardState);\n            case PieceType.ROOK:\n                return getPossibleRookMoves(piece, boardState);\n            case PieceType.QUEEN:\n                return getPossibleQueenMoves(piece, boardState);\n            case PieceType.KING:\n                return getPossibleKingMoves(piece, boardState);\n            default:\n                return [];\n        }\n    }\n\n    playMove(enPassantMove: boolean,\n        validMove: boolean,\n        playedPiece: Piece,\n        destination: Position): boolean {\n        const pawnDirection = playedPiece.team === TeamType.OUR ? 1 : -1;\n        const destinationPiece = this.pieces.find(p => p.samePosition(destination));\n\n        // If the move is a castling move do this\n        if (playedPiece.isKing && destinationPiece?.isRook\n            && destinationPiece.team === playedPiece.team) {\n            const direction = (destinationPiece.position.x - playedPiece.position.x > 0) ? 1 : -1;\n            const newKingXPosition = playedPiece.position.x + direction * 2;\n            this.pieces = this.pieces.map(p => {\n                if (p.samePiecePosition(playedPiece)) {\n                    p.position.x = newKingXPosition;\n                } else if (p.samePiecePosition(destinationPiece)) {\n                    p.position.x = newKingXPosition - direction;\n                }\n\n                return p;\n            });\n\n            this.calculateAllMoves();\n            return true;\n        }\n\n        if (enPassantMove) {\n            this.pieces = this.pieces.reduce((results, piece) => {\n                if (piece.samePiecePosition(playedPiece)) {\n                    if (piece.isPawn)\n                        (piece as Pawn).enPassant = false;\n                    piece.position.x = destination.x;\n                    piece.position.y = destination.y;\n                    piece.hasMoved = true;\n                    results.push(piece);\n                } else if (\n                    !piece.samePosition(new Position(destination.x, destination.y - pawnDirection))\n                ) {\n                    if (piece.isPawn) {\n                        (piece as Pawn).enPassant = false;\n                    }\n                    results.push(piece);\n                }\n\n                return results;\n            }, [] as Piece[]);\n\n            this.calculateAllMoves();\n        } else if (validMove) {\n            //UPDATES THE PIECE POSITION\n            //AND IF A PIECE IS ATTACKED, REMOVES IT\n            this.pieces = this.pieces.reduce((results, piece) => {\n                // Piece that we are currently moving\n                if (piece.samePiecePosition(playedPiece)) {\n                    //SPECIAL MOVE\n                    if (piece.isPawn)\n                        (piece as Pawn).enPassant =\n                            Math.abs(playedPiece.position.y - destination.y) === 2 &&\n                            piece.type === PieceType.PAWN;\n                    piece.position.x = destination.x;\n                    piece.position.y = destination.y;\n                    piece.hasMoved = true;\n                    results.push(piece);\n                } else if (!piece.samePosition(destination)) {\n                    if (piece.isPawn) {\n                        (piece as Pawn).enPassant = false;\n                    }\n                    results.push(piece);\n                }\n\n                // The piece at the destination location\n                // Won't be pushed in the results\n                return results;\n            }, [] as Piece[]);\n\n            this.calculateAllMoves();\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    updateTurns(x : number): void{\n        this.totalTurns = x;\n    }\n\n    clone(): Board {\n        return new Board(this.pieces.map(p => p.clone()),\n            this.totalTurns);\n    }\n}"],"mappings":"AAAA,SAASA,sBAAsB,EAAEC,oBAAoB,EAAEC,sBAAsB,EAAEC,oBAAoB,EAAEC,qBAAqB,EAAEC,oBAAoB,EAAEC,gBAAgB,QAAQ,kBAAkB;AAC5L,SAASC,SAAS,EAAEC,QAAQ,QAAQ,UAAU;AAG9C,SAASC,QAAQ,QAAQ,YAAY;AAErC,OAAO,MAAMC,KAAK,CAAC;EAKfC,WAAWA,CAACC,MAAe,EAAEC,UAAkB,EAAE;IAAA,KAJjDD,MAAM;IAAA,KACNC,UAAU;IAAA,KACVC,WAAW;IAGP,IAAI,CAACF,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAChC;EAEA,IAAIE,WAAWA,CAAA,EAAa;IACxB,OAAO,IAAI,CAACF,UAAU,GAAG,CAAC,KAAK,CAAC,GAAGL,QAAQ,CAACQ,QAAQ,GAAGR,QAAQ,CAACS,GAAG;EACvE;EAEAC,iBAAiBA,CAAA,EAAG;IAChB;IACA,KAAK,MAAMC,KAAK,IAAI,IAAI,CAACP,MAAM,EAAE;MAC7BO,KAAK,CAACC,aAAa,GAAG,IAAI,CAACC,aAAa,CAACF,KAAK,EAAE,IAAI,CAACP,MAAM,CAAC;IAChE;;IAEA;IACA,KAAK,MAAMU,IAAI,IAAI,IAAI,CAACV,MAAM,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,MAAM,CAAC,EAAE;MAClD,IAAIH,IAAI,CAACF,aAAa,KAAKM,SAAS,EAAE;MAEtCJ,IAAI,CAACF,aAAa,GAAG,CAAC,GAAGE,IAAI,CAACF,aAAa,EAAE,GAAGd,gBAAgB,CAACgB,IAAI,EAAE,IAAI,CAACV,MAAM,CAAC,CAAC;IACxF;;IAEA;IACA,IAAI,CAACe,qBAAqB,CAAC,CAAC;;IAE5B;IACA,KAAK,MAAMR,KAAK,IACZ,IAAI,CAACP,MAAM,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACI,IAAI,KAAK,IAAI,CAACb,WAAW,CAAC,EAAE;MACtDI,KAAK,CAACC,aAAa,GAAG,EAAE;IAC5B;;IAEA;IACA;IACA,IAAI,IAAI,CAACR,MAAM,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACI,IAAI,KAAK,IAAI,CAACb,WAAW,CAAC,CACnDc,IAAI,CAACL,CAAC,IAAIA,CAAC,CAACJ,aAAa,KAAKM,SAAS,IAAIF,CAAC,CAACJ,aAAa,CAACU,MAAM,GAAG,CAAC,CAAC,EAAE;IAE7E,IAAI,CAAChB,WAAW,GAAI,IAAI,CAACC,WAAW,KAAKP,QAAQ,CAACS,GAAG,GAAIT,QAAQ,CAACQ,QAAQ,GAAGR,QAAQ,CAACS,GAAG;EAC7F;EAEAU,qBAAqBA,CAAA,EAAG;IACpB;IACA,KAAK,MAAMR,KAAK,IAAI,IAAI,CAACP,MAAM,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACI,IAAI,KAAK,IAAI,CAACb,WAAW,CAAC,EAAE;MACtE,IAAII,KAAK,CAACC,aAAa,KAAKM,SAAS,EAAE;;MAEvC;MACA,KAAK,MAAMK,IAAI,IAAIZ,KAAK,CAACC,aAAa,EAAE;QACpC,MAAMY,cAAc,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;;QAEnC;QACAD,cAAc,CAACpB,MAAM,GAAGoB,cAAc,CAACpB,MAAM,CAACW,MAAM,CAACC,CAAC,IAAI,CAACA,CAAC,CAACU,YAAY,CAACH,IAAI,CAAC,CAAC;;QAEhF;QACA,MAAMI,WAAW,GAAGH,cAAc,CAACpB,MAAM,CAACwB,IAAI,CAACZ,CAAC,IAAIA,CAAC,CAACa,iBAAiB,CAAClB,KAAK,CAAC,CAAE;QAChF;QACA,IAAGgB,WAAW,EAAEA,WAAW,CAACG,QAAQ,GAAGP,IAAI,CAACE,KAAK,CAAC,CAAC;;QAEnD;QACA,MAAMM,UAAU,GAAGP,cAAc,CAACpB,MAAM,CAACwB,IAAI,CAACZ,CAAC,IAAIA,CAAC,CAACC,MAAM,IAAID,CAAC,CAACI,IAAI,KAAKI,cAAc,CAACjB,WAAW,CAAE;;QAEtG;QACA;QACA,KAAK,MAAMyB,KAAK,IAAIR,cAAc,CAACpB,MAAM,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACI,IAAI,KAAKI,cAAc,CAACjB,WAAW,CAAC,EAAE;UAC1FyB,KAAK,CAACpB,aAAa,GAAGY,cAAc,CAACX,aAAa,CAACmB,KAAK,EAAER,cAAc,CAACpB,MAAM,CAAC;UAEhF,IAAI4B,KAAK,CAACC,MAAM,EAAE;YACd,IAAID,KAAK,CAACpB,aAAa,CAACS,IAAI,CAACa,CAAC,IAAIA,CAAC,CAACC,CAAC,KAAKH,KAAK,CAACF,QAAQ,CAACK,CAAC,IACnDD,CAAC,CAACR,YAAY,CAACK,UAAU,CAACD,QAAQ,CAAC,CAAC,EAAE;cAAA,IAAAM,oBAAA;cACzCzB,KAAK,CAACC,aAAa,IAAAwB,oBAAA,GAAGzB,KAAK,CAACC,aAAa,cAAAwB,oBAAA,uBAAnBA,oBAAA,CAAqBrB,MAAM,CAACmB,CAAC,IAAI,CAACA,CAAC,CAACR,YAAY,CAACH,IAAI,CAAC,CAAC;YACjF;UACJ,CAAC,MAAM;YACH,IAAIS,KAAK,CAACpB,aAAa,CAACS,IAAI,CAACa,CAAC,IAAIA,CAAC,CAACR,YAAY,CAACK,UAAU,CAACD,QAAQ,CAAC,CAAC,EAAE;cAAA,IAAAO,qBAAA;cACpE1B,KAAK,CAACC,aAAa,IAAAyB,qBAAA,GAAG1B,KAAK,CAACC,aAAa,cAAAyB,qBAAA,uBAAnBA,qBAAA,CAAqBtB,MAAM,CAACmB,CAAC,IAAI,CAACA,CAAC,CAACR,YAAY,CAACH,IAAI,CAAC,CAAC;YACjF;UACJ;QACJ;MACJ;IACJ;EACJ;EAEAV,aAAaA,CAACF,KAAY,EAAE2B,UAAmB,EAAc;IACzD,QAAQ3B,KAAK,CAAC4B,IAAI;MACd,KAAKxC,SAAS,CAACyC,IAAI;QACf,OAAO7C,oBAAoB,CAACgB,KAAK,EAAE2B,UAAU,CAAC;MAClD,KAAKvC,SAAS,CAAC0C,MAAM;QACjB,OAAO/C,sBAAsB,CAACiB,KAAK,EAAE2B,UAAU,CAAC;MACpD,KAAKvC,SAAS,CAAC2C,MAAM;QACjB,OAAOlD,sBAAsB,CAACmB,KAAK,EAAE2B,UAAU,CAAC;MACpD,KAAKvC,SAAS,CAAC4C,IAAI;QACf,OAAO9C,oBAAoB,CAACc,KAAK,EAAE2B,UAAU,CAAC;MAClD,KAAKvC,SAAS,CAAC6C,KAAK;QAChB,OAAOhD,qBAAqB,CAACe,KAAK,EAAE2B,UAAU,CAAC;MACnD,KAAKvC,SAAS,CAAC8C,IAAI;QACf,OAAOpD,oBAAoB,CAACkB,KAAK,EAAE2B,UAAU,CAAC;MAClD;QACI,OAAO,EAAE;IACjB;EACJ;EAEAQ,QAAQA,CAACC,aAAsB,EAC3BC,SAAkB,EAClBC,WAAkB,EAClBC,WAAqB,EAAW;IAChC,MAAMC,aAAa,GAAGF,WAAW,CAAC7B,IAAI,KAAKpB,QAAQ,CAACS,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;IAChE,MAAM2C,gBAAgB,GAAG,IAAI,CAAChD,MAAM,CAACwB,IAAI,CAACZ,CAAC,IAAIA,CAAC,CAACU,YAAY,CAACwB,WAAW,CAAC,CAAC;;IAE3E;IACA,IAAID,WAAW,CAAChC,MAAM,IAAImC,gBAAgB,aAAhBA,gBAAgB,eAAhBA,gBAAgB,CAAEC,MAAM,IAC3CD,gBAAgB,CAAChC,IAAI,KAAK6B,WAAW,CAAC7B,IAAI,EAAE;MAC/C,MAAMkC,SAAS,GAAIF,gBAAgB,CAACtB,QAAQ,CAACK,CAAC,GAAGc,WAAW,CAACnB,QAAQ,CAACK,CAAC,GAAG,CAAC,GAAI,CAAC,GAAG,CAAC,CAAC;MACrF,MAAMoB,gBAAgB,GAAGN,WAAW,CAACnB,QAAQ,CAACK,CAAC,GAAGmB,SAAS,GAAG,CAAC;MAC/D,IAAI,CAAClD,MAAM,GAAG,IAAI,CAACA,MAAM,CAACoD,GAAG,CAACxC,CAAC,IAAI;QAC/B,IAAIA,CAAC,CAACa,iBAAiB,CAACoB,WAAW,CAAC,EAAE;UAClCjC,CAAC,CAACc,QAAQ,CAACK,CAAC,GAAGoB,gBAAgB;QACnC,CAAC,MAAM,IAAIvC,CAAC,CAACa,iBAAiB,CAACuB,gBAAgB,CAAC,EAAE;UAC9CpC,CAAC,CAACc,QAAQ,CAACK,CAAC,GAAGoB,gBAAgB,GAAGD,SAAS;QAC/C;QAEA,OAAOtC,CAAC;MACZ,CAAC,CAAC;MAEF,IAAI,CAACN,iBAAiB,CAAC,CAAC;MACxB,OAAO,IAAI;IACf;IAEA,IAAIqC,aAAa,EAAE;MACf,IAAI,CAAC3C,MAAM,GAAG,IAAI,CAACA,MAAM,CAACqD,MAAM,CAAC,CAACC,OAAO,EAAE/C,KAAK,KAAK;QACjD,IAAIA,KAAK,CAACkB,iBAAiB,CAACoB,WAAW,CAAC,EAAE;UACtC,IAAItC,KAAK,CAACsB,MAAM,EACXtB,KAAK,CAAUgD,SAAS,GAAG,KAAK;UACrChD,KAAK,CAACmB,QAAQ,CAACK,CAAC,GAAGe,WAAW,CAACf,CAAC;UAChCxB,KAAK,CAACmB,QAAQ,CAAC8B,CAAC,GAAGV,WAAW,CAACU,CAAC;UAChCjD,KAAK,CAACkD,QAAQ,GAAG,IAAI;UACrBH,OAAO,CAACI,IAAI,CAACnD,KAAK,CAAC;QACvB,CAAC,MAAM,IACH,CAACA,KAAK,CAACe,YAAY,CAAC,IAAIzB,QAAQ,CAACiD,WAAW,CAACf,CAAC,EAAEe,WAAW,CAACU,CAAC,GAAGT,aAAa,CAAC,CAAC,EACjF;UACE,IAAIxC,KAAK,CAACsB,MAAM,EAAE;YACbtB,KAAK,CAAUgD,SAAS,GAAG,KAAK;UACrC;UACAD,OAAO,CAACI,IAAI,CAACnD,KAAK,CAAC;QACvB;QAEA,OAAO+C,OAAO;MAClB,CAAC,EAAE,EAAa,CAAC;MAEjB,IAAI,CAAChD,iBAAiB,CAAC,CAAC;IAC5B,CAAC,MAAM,IAAIsC,SAAS,EAAE;MAClB;MACA;MACA,IAAI,CAAC5C,MAAM,GAAG,IAAI,CAACA,MAAM,CAACqD,MAAM,CAAC,CAACC,OAAO,EAAE/C,KAAK,KAAK;QACjD;QACA,IAAIA,KAAK,CAACkB,iBAAiB,CAACoB,WAAW,CAAC,EAAE;UACtC;UACA,IAAItC,KAAK,CAACsB,MAAM,EACXtB,KAAK,CAAUgD,SAAS,GACrBI,IAAI,CAACC,GAAG,CAACf,WAAW,CAACnB,QAAQ,CAAC8B,CAAC,GAAGV,WAAW,CAACU,CAAC,CAAC,KAAK,CAAC,IACtDjD,KAAK,CAAC4B,IAAI,KAAKxC,SAAS,CAACyC,IAAI;UACrC7B,KAAK,CAACmB,QAAQ,CAACK,CAAC,GAAGe,WAAW,CAACf,CAAC;UAChCxB,KAAK,CAACmB,QAAQ,CAAC8B,CAAC,GAAGV,WAAW,CAACU,CAAC;UAChCjD,KAAK,CAACkD,QAAQ,GAAG,IAAI;UACrBH,OAAO,CAACI,IAAI,CAACnD,KAAK,CAAC;QACvB,CAAC,MAAM,IAAI,CAACA,KAAK,CAACe,YAAY,CAACwB,WAAW,CAAC,EAAE;UACzC,IAAIvC,KAAK,CAACsB,MAAM,EAAE;YACbtB,KAAK,CAAUgD,SAAS,GAAG,KAAK;UACrC;UACAD,OAAO,CAACI,IAAI,CAACnD,KAAK,CAAC;QACvB;;QAEA;QACA;QACA,OAAO+C,OAAO;MAClB,CAAC,EAAE,EAAa,CAAC;MAEjB,IAAI,CAAChD,iBAAiB,CAAC,CAAC;IAC5B,CAAC,MAAM;MACH,OAAO,KAAK;IAChB;IAEA,OAAO,IAAI;EACf;EAEAuD,WAAWA,CAAC9B,CAAU,EAAO;IACzB,IAAI,CAAC9B,UAAU,GAAG8B,CAAC;EACvB;EAEAV,KAAKA,CAAA,EAAU;IACX,OAAO,IAAIvB,KAAK,CAAC,IAAI,CAACE,MAAM,CAACoD,GAAG,CAACxC,CAAC,IAAIA,CAAC,CAACS,KAAK,CAAC,CAAC,CAAC,EAC5C,IAAI,CAACpB,UAAU,CAAC;EACxB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}