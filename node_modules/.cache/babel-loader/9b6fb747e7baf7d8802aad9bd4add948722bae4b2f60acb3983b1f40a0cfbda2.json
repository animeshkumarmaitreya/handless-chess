{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent } from \"./GeneralRules\";\nexport const knightMove = (initialPosition, desiredPosition, team, boardState) => {\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      //TOP AND BOTTOM SIDE MOVEMENT\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team)) {\n            return true;\n          }\n        }\n      }\n\n      //RIGHT AND LEFT SIDE MOVEMENT\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleKnightMoves = (knight, boardstate) => {\n  const possibleMoves = [];\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      const verticalMove = new Position(knight.position.x + j, knight.position.y + i * 2);\n      const horizontalMove = new Position(knight.position.x + i * 2, knight.position.y + j);\n      if (tileIsEmptyOrOccupiedByOpponent(verticalMove, boardstate, knight.team)) {\n        possibleMoves.push(verticalMove);\n      }\n      if (tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardstate, knight.team)) {\n        possibleMoves.push(horizontalMove);\n      }\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileIsEmptyOrOccupiedByOpponent","knightMove","initialPosition","desiredPosition","team","boardState","i","j","y","x","getPossibleKnightMoves","knight","boardstate","possibleMoves","verticalMove","position","horizontalMove","push"],"sources":["/home/animesh/Desktop/SummerDev/Chess-40/src/Referee/rules/KnightRules.ts"],"sourcesContent":["import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const knightMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      //TOP AND BOTTOM SIDE MOVEMENT\n      if (desiredPosition.y - initialPosition.y === 2 * i) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(\n              desiredPosition,\n              boardState,\n              team\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n\n      //RIGHT AND LEFT SIDE MOVEMENT\n      if (desiredPosition.x - initialPosition.x === 2 * i) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          if (\n            tileIsEmptyOrOccupiedByOpponent(\n              desiredPosition,\n              boardState,\n              team\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport const getPossibleKnightMoves = (knight: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      const verticalMove = new Position(knight.position.x + j, knight.position.y + i * 2);\n      const horizontalMove = new Position(knight.position.x + i * 2, knight.position.y + j);\n\n      if(tileIsEmptyOrOccupiedByOpponent(verticalMove, boardstate, knight.team)) {\n        possibleMoves.push(verticalMove);\n      }\n\n      if(tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardstate, knight.team)) {\n        possibleMoves.push(horizontalMove);\n      }\n    }\n  }\n\n  return possibleMoves;\n}"],"mappings":"AAAA,SAAgBA,QAAQ,QAAQ,cAAc;AAE9C,SAASC,+BAA+B,QAAQ,gBAAgB;AAEhE,OAAO,MAAMC,UAAU,GAAGA,CAACC,eAAyB,EAAEC,eAAyB,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EAChI,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC9B;MACA,IAAIJ,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,KAAK,CAAC,GAAGF,CAAC,EAAE;QACnD,IAAIH,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAKF,CAAC,EAAE;UAC/C,IACEP,+BAA+B,CAC7BG,eAAe,EACfE,UAAU,EACVD,IACF,CAAC,EACD;YACA,OAAO,IAAI;UACb;QACF;MACF;;MAEA;MACA,IAAID,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAK,CAAC,GAAGH,CAAC,EAAE;QACnD,IAAIH,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,KAAKD,CAAC,EAAE;UAC/C,IACEP,+BAA+B,CAC7BG,eAAe,EACfE,UAAU,EACVD,IACF,CAAC,EACD;YACA,OAAO,IAAI;UACb;QACF;MACF;IACF;EACF;EACA,OAAO,KAAK;AACd,CAAC;AAED,OAAO,MAAMM,sBAAsB,GAAGA,CAACC,MAAa,EAAEC,UAAmB,KAAiB;EACxF,MAAMC,aAAyB,GAAG,EAAE;EAEpC,KAAK,IAAIP,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MAC9B,MAAMO,YAAY,GAAG,IAAIf,QAAQ,CAACY,MAAM,CAACI,QAAQ,CAACN,CAAC,GAAGF,CAAC,EAAEI,MAAM,CAACI,QAAQ,CAACP,CAAC,GAAGF,CAAC,GAAG,CAAC,CAAC;MACnF,MAAMU,cAAc,GAAG,IAAIjB,QAAQ,CAACY,MAAM,CAACI,QAAQ,CAACN,CAAC,GAAGH,CAAC,GAAG,CAAC,EAAEK,MAAM,CAACI,QAAQ,CAACP,CAAC,GAAGD,CAAC,CAAC;MAErF,IAAGP,+BAA+B,CAACc,YAAY,EAAEF,UAAU,EAAED,MAAM,CAACP,IAAI,CAAC,EAAE;QACzES,aAAa,CAACI,IAAI,CAACH,YAAY,CAAC;MAClC;MAEA,IAAGd,+BAA+B,CAACgB,cAAc,EAAEJ,UAAU,EAAED,MAAM,CAACP,IAAI,CAAC,EAAE;QAC3ES,aAAa,CAACI,IAAI,CAACD,cAAc,CAAC;MACpC;IACF;EACF;EAEA,OAAOH,aAAa;AACtB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}