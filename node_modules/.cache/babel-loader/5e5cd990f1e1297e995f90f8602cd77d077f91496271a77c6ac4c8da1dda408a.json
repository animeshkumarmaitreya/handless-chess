{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const queenMove = (initialPosition, desiredPosition, team, boardState) => {\n  for (let i = 1; i < 8; i++) {\n    //Diagonal\n    let multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n    let multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n    let passedPosition = new Position(initialPosition.x + i * multiplierX, initialPosition.y + i * multiplierY);\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true;\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleQueenMoves = (queen, boardstate) => {\n  const possibleMoves = [];\n\n  // Top movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x, queen.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x, queen.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x + i, queen.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(queen.position.x - i, queen.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileIsEmptyOrOccupiedByOpponent","tileIsOccupied","tileIsOccupiedByOpponent","queenMove","initialPosition","desiredPosition","team","boardState","i","multiplierX","x","multiplierY","y","passedPosition","samePosition","getPossibleQueenMoves","queen","boardstate","possibleMoves","destination","position","push"],"sources":["/home/animesh/Desktop/SummerDev/Chess-40/src/Referee/rules/QueenRules.ts"],"sourcesContent":["import { TeamType } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const queenMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    for(let i = 1; i < 8; i++) {\n      //Diagonal\n      let multiplierX = (desiredPosition.x < initialPosition.x) ? -1 : (desiredPosition.x > initialPosition.x) ? 1 : 0;\n      let multiplierY = (desiredPosition.y < initialPosition.y) ? -1 : (desiredPosition.y > initialPosition.y) ? 1 : 0;\n\n      let passedPosition = new Position(initialPosition.x + (i * multiplierX), initialPosition.y + (i * multiplierY));\n\n      if(passedPosition.samePosition(desiredPosition)) {\n        if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if(tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleQueenMoves = (queen: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Top movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Upper right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x + i, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Top left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(queen.position.x - i, queen.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, queen.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}