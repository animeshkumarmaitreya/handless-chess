{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const kingMove = (initialPosition, desiredPosition, team, boardState) => {\n  for (let i = 1; i < 2; i++) {\n    //Diagonal\n    let multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n    let multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n    let passedPosition = new Position(initialPosition.x + i * multiplierX, initialPosition.y + i * multiplierY);\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true;\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleKingMoves = (king, boardstate) => {\n  const possibleMoves = [];\n\n  // Top movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if (destination.x < 0 || destination.x > 7 || destination.y < 0 || destination.y > 7) {\n      break;\n    }\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};\n\n// In this method the enemy moves have already been calculated\nexport const getCastlingMoves = (king, boardstate) => {\n  const possibleMoves = [];\n  if (king.hasMoved) return possibleMoves;\n\n  // We get the rooks from the king's team which haven't moved\n  const rooks = boardstate.filter(p => p.isRook && p.team === king.team && !p.hasMoved);\n\n  // Loop through the rooks\n  for (const rook of rooks) {\n    var _rook$possibleMoves;\n    // Determine if we need to go to the right or the left side\n    const direction = rook.position.x - king.position.x > 0 ? 1 : -1;\n    const adjacentPosition = king.position.clone();\n    adjacentPosition.x += direction;\n    if (!((_rook$possibleMoves = rook.possibleMoves) !== null && _rook$possibleMoves !== void 0 && _rook$possibleMoves.some(m => m.samePosition(adjacentPosition)))) continue;\n\n    // We know that the rook can move to the adjacent side of the king\n\n    const conceringTiles = rook.possibleMoves.filter(m => m.y === king.position.y);\n\n    // Checking if any of the enemy pieces can attack the spaces between\n    // The rook and the king\n    const enemyPieces = boardstate.filter(p => p.team !== king.team);\n    let valid = true;\n    for (const enemy of enemyPieces) {\n      if (enemy.possibleMoves === undefined) continue;\n      for (const move of enemy.possibleMoves) {\n        if (conceringTiles.some(t => t.samePosition(move))) {\n          valid = false;\n        }\n        if (!valid) break;\n      }\n      if (!valid) break;\n    }\n    if (!valid) continue;\n\n    // We now want to add it as a possible move!\n    possibleMoves.push(rook.position.clone());\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileIsEmptyOrOccupiedByOpponent","tileIsOccupied","tileIsOccupiedByOpponent","kingMove","initialPosition","desiredPosition","team","boardState","i","multiplierX","x","multiplierY","y","passedPosition","samePosition","getPossibleKingMoves","king","boardstate","possibleMoves","destination","position","push","getCastlingMoves","hasMoved","rooks","filter","p","isRook","rook","_rook$possibleMoves","direction","adjacentPosition","clone","some","m","conceringTiles","enemyPieces","valid","enemy","undefined","move","t"],"sources":["/home/animesh/Desktop/SummerDev/handless-chess/src/Referee/rules/KingRules.ts"],"sourcesContent":["import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const kingMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n  for (let i = 1; i < 2; i++) {\n    //Diagonal\n    let multiplierX = (desiredPosition.x < initialPosition.x) ? -1 : (desiredPosition.x > initialPosition.x) ? 1 : 0;\n    let multiplierY = (desiredPosition.y < initialPosition.y) ? -1 : (desiredPosition.y > initialPosition.y) ? 1 : 0;\n\n    let passedPosition = new Position(initialPosition.x + (i * multiplierX), initialPosition.y + (i * multiplierY));\n\n    if (passedPosition.samePosition(desiredPosition)) {\n      if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n        return true;\n      }\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n}\n\nexport const getPossibleKingMoves = (king: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  // Top movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Upper right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x + i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y - i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 2; i++) {\n    const destination = new Position(king.position.x - i, king.position.y + i);\n\n    // If the move is outside of the board don't add it\n    if(destination.x < 0 || destination.x > 7 \n      || destination.y < 0 || destination.y > 7) {\n        break;\n    }\n    \n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return possibleMoves;\n}\n\n// In this method the enemy moves have already been calculated\nexport const getCastlingMoves = (king: Piece, boardstate: Piece[]): Position[] => {\n  const possibleMoves: Position[] = [];\n\n  if (king.hasMoved) return possibleMoves;\n\n  // We get the rooks from the king's team which haven't moved\n  const rooks = boardstate.filter(p => p.isRook\n    && p.team === king.team && !p.hasMoved);\n\n  // Loop through the rooks\n  for (const rook of rooks) {\n    // Determine if we need to go to the right or the left side\n    const direction = (rook.position.x - king.position.x > 0) ? 1 : -1;\n\n    const adjacentPosition = king.position.clone();\n    adjacentPosition.x += direction;\n\n    if(!rook.possibleMoves?.some(m => m.samePosition(adjacentPosition))) continue;\n\n    // We know that the rook can move to the adjacent side of the king\n\n    const conceringTiles = rook.possibleMoves.filter(m => m.y === king.position.y);\n\n    // Checking if any of the enemy pieces can attack the spaces between\n    // The rook and the king\n    const enemyPieces = boardstate.filter(p => p.team !== king.team);\n\n    let valid = true;\n\n    for(const enemy of enemyPieces) {\n      if(enemy.possibleMoves === undefined) continue;\n\n      for(const move of enemy.possibleMoves) {\n        if(conceringTiles.some(t => t.samePosition(move))) {\n          valid = false;\n        }\n\n        if(!valid)\n          break;\n      }\n\n      if(!valid)\n        break;\n    }\n\n    if(!valid) continue;\n\n    // We now want to add it as a possible move!\n    possibleMoves.push(rook.position.clone());\n  }\n\n\n  return possibleMoves;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}