{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const rookMove = (initialPosition, desiredPosition, team, boardState) => {\n  if (initialPosition.x === desiredPosition.x) {\n    for (let i = 1; i < 8; i++) {\n      let multiplier = desiredPosition.y < initialPosition.y ? -1 : 1;\n      let passedPosition = new Position(initialPosition.x, initialPosition.y + i * multiplier);\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  if (initialPosition.y === desiredPosition.y) {\n    for (let i = 1; i < 8; i++) {\n      let multiplier = desiredPosition.x < initialPosition.x ? -1 : 1;\n      let passedPosition = new Position(initialPosition.x + i * multiplier, initialPosition.y);\n      if (passedPosition.samePosition(desiredPosition)) {\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleRookMoves = (rook, boardstate) => {\n  const possibleMoves = [];\n\n  // Top movement\n  for (let i = 1; i < 8; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.y + i > 7) break;\n    const destination = new Position(rook.position.x, rook.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom movement\n  for (let i = 1; i < 8; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.y - i < 0) break;\n    const destination = new Position(rook.position.x, rook.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Left movement\n  for (let i = 1; i < 8; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.x - i < 0) break;\n    const destination = new Position(rook.position.x - i, rook.position.y);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Right movement\n  for (let i = 1; i < 8; i++) {\n    // Stop checking if move is outside of the board\n    if (rook.position.x + i > 7) break;\n    const destination = new Position(rook.position.x + i, rook.position.y);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileIsEmptyOrOccupiedByOpponent","tileIsOccupied","tileIsOccupiedByOpponent","rookMove","initialPosition","desiredPosition","team","boardState","x","i","multiplier","y","passedPosition","samePosition","getPossibleRookMoves","rook","boardstate","possibleMoves","position","destination","push"],"sources":["/home/animesh/Desktop/SummerDev/Chess-40/src/Referee/rules/RookRules.ts"],"sourcesContent":["import { TeamType } from \"../../Types\";\nimport { Piece, Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const rookMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    if(initialPosition.x === desiredPosition.x) {\n      for(let i = 1; i < 8; i++) {\n        let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n\n        let passedPosition = new Position(initialPosition.x, initialPosition.y + (i * multiplier));\n        if(passedPosition.samePosition(desiredPosition)) {\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n\n    if(initialPosition.y === desiredPosition.y) {\n      for(let i = 1; i < 8; i++) {\n        let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n\n        let passedPosition = new Position(initialPosition.x + (i * multiplier), initialPosition.y);\n        if(passedPosition.samePosition(desiredPosition)) {\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleRookMoves = (rook: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Top movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.y + i > 7) break;\n      const destination = new Position(rook.position.x, rook.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.y - i < 0) break;\n\n      const destination = new Position(rook.position.x, rook.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Left movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.x - i < 0) break;\n\n      const destination = new Position(rook.position.x - i, rook.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Right movement\n    for(let i = 1; i < 8; i++) {\n      // Stop checking if move is outside of the board\n      if(rook.position.x + i > 7) break;\n\n      const destination = new Position(rook.position.x + i, rook.position.y);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, rook.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}