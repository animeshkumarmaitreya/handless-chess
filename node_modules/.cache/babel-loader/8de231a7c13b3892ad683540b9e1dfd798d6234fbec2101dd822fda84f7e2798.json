{"ast":null,"code":"import { Position } from \"../../models\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const bishopMove = (initialPosition, desiredPosition, team, boardState) => {\n  for (let i = 1; i < 8; i++) {\n    //Up right movement\n    if (desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n      let passedPosition = new Position(initialPosition.x + i, initialPosition.y + i);\n      //Check if the tile is the destination tile\n      if (passedPosition.samePosition(desiredPosition)) {\n        //Dealing with destination tile\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        //Dealing with passing tile\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    //Bottom right movement\n    if (desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n      let passedPosition = new Position(initialPosition.x + i, initialPosition.y - i);\n      //Check if the tile is the destination tile\n      if (passedPosition.samePosition(desiredPosition)) {\n        //Dealing with destination tile\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    //Bottom left movement\n    if (desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n      let passedPosition = new Position(initialPosition.x - i, initialPosition.y - i);\n      //Check if the tile is the destination tile\n      if (passedPosition.samePosition(desiredPosition)) {\n        //Dealing with destination tile\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n\n    //Top left movement\n    if (desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n      let passedPosition = new Position(initialPosition.x - i, initialPosition.y + i);\n      //Check if the tile is the destination tile\n      if (passedPosition.samePosition(desiredPosition)) {\n        //Dealing with destination tile\n        if (tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n          return true;\n        }\n      } else {\n        if (tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleBishopMoves = (bishop, boardstate) => {\n  const possibleMoves = [];\n\n  // Upper right movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x + i, bishop.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom right movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x + i, bishop.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Bottom left movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x - i, bishop.position.y - i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Top left movement\n  for (let i = 1; i < 8; i++) {\n    const destination = new Position(bishop.position.x - i, bishop.position.y + i);\n    if (!tileIsOccupied(destination, boardstate)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["Position","tileIsEmptyOrOccupiedByOpponent","tileIsOccupied","tileIsOccupiedByOpponent","bishopMove","initialPosition","desiredPosition","team","boardState","i","x","y","passedPosition","samePosition","getPossibleBishopMoves","bishop","boardstate","possibleMoves","destination","position","push"],"sources":["/home/animesh/Desktop/SummerDev/handless-chess/src/Referee/rules/BishopRules.ts"],"sourcesContent":["import { Piece, Position } from \"../../models\";\nimport { TeamType } from \"../../Types\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const bishopMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    for(let i = 1; i < 8; i++) {\n      //Up right movement\n      if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x + i, initialPosition.y + i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          //Dealing with passing tile\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n        \n      //Bottom right movement\n      if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x + i, initialPosition.y - i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      //Bottom left movement\n      if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x - i, initialPosition.y - i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      //Top left movement\n      if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = new Position(initialPosition.x - i, initialPosition.y+i);\n        //Check if the tile is the destination tile\n        if(passedPosition.samePosition(desiredPosition)) {\n          //Dealing with destination tile\n          if(tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team)) {\n            return true;\n          }\n        } else {\n          if(tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  export const getPossibleBishopMoves = (bishop: Piece, boardstate: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n\n    // Upper right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x + i, bishop.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom right movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x + i, bishop.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Bottom left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x - i, bishop.position.y - i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    // Top left movement\n    for(let i = 1; i < 8; i++) {\n      const destination = new Position(bishop.position.x - i, bishop.position.y + i);\n\n      if(!tileIsOccupied(destination, boardstate)) {\n        possibleMoves.push(destination);\n      } else if(tileIsOccupiedByOpponent(destination, boardstate, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return possibleMoves;\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}